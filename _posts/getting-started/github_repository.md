---
layout: post
template: one-col
title:  "Onboarding"
date:   2036-12-24 10:51:22
cloud66_text: "Try Cloud 66 for free"
cloud66_sticky: true
categories: getting-started
lead: Walk through onboarding
search-tags: ['gce', 'google', 'google cloud', 'compute engine', 'google compute engine']
tags: ['']
---

<h2>Contents</h2>
<ul class="page-toc">
    <li><a href="#add_your_docker_services">Add your Docker Services</a></li>
        <ul>
            <li><a href="#service_provider">Choose Service provider</a></li>
            <li>
            <ul>
                <li><a href="#custome_git_repo">I'm using another Git repo</a></li>
                <li><a href="#github_repo">I'm using a GitHub repo</a></li>
                <li><a href="#image_repo">It's a Docker image</a></li>
            </ul>
            </li>
        </ul>
    <li><a href="#Deploy">Build/Deploy</a></li>
    <li>
        <ul>
            <li><a href="#build_all">Build All</a></li>
            <li><a href="#build_options">Build Options</a></li>
            <li><a href="#setup_deployments">Setup Deployments</a></li>
            <li>
            <ul>
               <li><a href="#environment">Choosing Environment</a></li>
               <li><a href="#service_networking">Service Networking</a></li>
               <li><a href="#data_sources">Adding Data Sources</a></li>
               <li><a href="#choosing_cloud">Choosing Cloud</a></li>
               <li><a href="#choosing_server">Choosing Server Size</a></li>
            </ul>
            </li>
        </ul>
        </li>
</li>
</ul>


<h2 id="add_your_docker_services">Add your Docker Services</h2>

When building your Docker stack, you can either let us create them for you with our powerful cluster of servers called BuildGrid, or provide us with your own image. When using BuildGrid, your image is built based on your source code and a Dockerfile, which specifies how you want it to be created.

Using BuildGrid lets you focus on what you do best and avoids you having to create internal processes to output Docker images. You can even integrate your CI solution, so that new images are built and pushed to your servers once all your tests pass.


<h3 id="service_provider">Choose Service provider</h3>

<h3 id="custome_git_repo">I'm using another Git repo</h3>

If you prefer to build your own images, simply provide the location of this image (whether public or private) with the image directive in your service configuration.

The source repository of your Docker image, which can come from a private repository (You may need to provide credentials to let Cloud 66 has access to).


Name formatting of your Docker image

The format for image repositries:

Docker Hub: <namespace>/<image_name>:/<tag>

example: projectmoon/moon_buggy:/latest

Quay: <image provider>/<namespace>/<image_name>:/<tag> 

example: quay.io/projectmoon/moon_buggy:/19670208124940314

Google Container Registry: <image provider>/<project_id>/<namespace>/<image_name>:/<tag>

example: gcr.io/appolo15/projectmoon/moon_buggy:/19670208124940314

Amazon EC2 Container Registry (ECR) : <image provider>/<namespace>/<image_name>:/<tag>

example: 123456789012.dkr.ecr.eu-west-1.amazonaws.com/projectmoon/moon_buggy:/19670208124940314




<h3 id="github_repo">I'm using a GitHub repo</h3>

In order to be able to list your git-hub projects we need to link your Cloud 66 account to your Git-hub account.



<h3 custome_git_repo">I'm using another Git repo</h3>

<h2>Contents</h2>
<ul class="page-toc" style="margin-bottom:0em">
	<li>
		<a href="#public">Public repositories</a>
	</li>
	<li><a href="#private">Private repositories</a></li>
            <ul style="margin-bottom:0em; margin-top:0em">
                <li><a href="#github">GitHub example</a></li>
                <li><a href="#bitbucket">BitBucket example</a></li>
            </ul>
        
</ul>

<h2 id="public">Public repositories</h2>
For public Git repositories, you don't need to add the SSH key provided to your Git account. You simply need to provide the Git URL as either

`http://<git provider>/<username>/<repository>.git`<br/>
or <br/>
`git://<git provider>/<username>/<repository>.git`

<div class="notice notice-warning">
    <h3>Notice</h3>
    <p>We do not support the use of HTTPS URLs.</p>
</div>

This URL is often generated by your Git provider automatically.

<h2 id="private">Private repositories</h2>

For Cloud 66 to access your private repository (with read-only access), you first need to add the SSH provided to your Git account. Follow the instructions on the <i>Get started building your stack</i> page, clicking the <i>How?</i> link.

You can add this SSH key globally to your GitHub account by adding it to your _Account settings_ page, or allow access to a specific repository by adding it as a _Deploy key_ to that repository.

Once this is done, use a Git URL in the following format:

`git@<git provider>:<username>/<repository>.git`

This URL is often generated by your Git provider automatically.

<h3 id="github">GitHub example</h3>
<ol class="article-list">
<li>Adding the SSH key globally</li>
<p>To add the SSH key globally, click the <i>Account settings</i> in the top right hand corner, and then <i>SSH keys</i> in the left menu (you can also choose a name).</p>
<li>Adding the SSH key to a specific repository</li>
<p>To add the SSH key to a specific repository, first access the <i>Settings</i> menu for that repository.
Now simply click <i>Deploy keys</i> and paste your key there (you can also choose a name)</p>
</ol>

Once this is done, use a Git URL in the following format in the Cloud 66 UI:

`git@github.com:<username>/<repository>.git`

<h3 id="bitbucket">BitBucket example</h3>
<ol class="article-list">
<li>Adding the SSH key globally</li>
<p>To add the SSH key globally, click <i>Manage account</i> in the top right hand corner, and then <i>SSH keys</i> in the left menu (you can also choose a name).</p>
<li>Adding the SSH key to a specific repository</li>
<p>To add the SSH key to a specific repository, first access the <i>Settings</i> menu for that repository (top right), then click <i>Deployment keys</i> and paste your key there.</p>
</ol>

Once this is done, use a Git URL in the following format in the Cloud 66 UI:

`git@bitbucket.org:<username>/<repository>.git`


<h3 id="Deploy">Build/Deploy</h3>
<h3 id="environment">Choosing Environment</h3>

1. PostgreSQL
2. MySQL
3. MongoDB
4. Redis
5. ElasticSearch
6. Rabbit MQ
7. Glusterf
8. Influxdb

<h3 id="service_networking">Service Networking</h3>

Container Port:

A normal application listens to port 3000 or 9292 by default.

Public Internet Port: 

Often times the purpose of a service inside your application is to respond to web queries from the internet. Actions like rendering and serving HTML pages or accepting HTTP POST actions are amongst the most common requirements from web services.

In a Cloud 66 for Docker stack, your services run inside containers. For this service to be available to anyone outside the container, we need to bridge it from inside to outside of the container.

This is not limited to HTTP or web traffic. The same concepts apply if your container serves non-HTTP traffic (like web sockets, DB containers or custom TCP / UDP traffic).
Note

In this article, outside world is used for any client of your service that's not inside the container. This includes any other services on your other stacks.
Ports inside and outside containers

Your code that runs inside of a container listens to a specific port. For example a standard setup for a web server listens to port 80 for HTTP and 443 for HTTPS traffic. A normal Rails application listens to port 3000 or 9292 by default.

Here is an example of default ports used by different programming frameworks or application servers:
Application 	Default Port
Rack (webrick)	3000
Rack (unicorn, thin, puma)	9292
Node (Express)	3000
Java (Play)	9000
RethinkDB	8080
InfluxDB	8083, 8086, 8090, 8099

From the outside world (ie Internet) all of these applications (except for the DBs) listen to the normal HTTP (80) and HTTPS (443) ports so the site visitors donâ€™t need to enter port number in their browsers.

On a Cloud 66 for Docker stack, you can make the inside and outside ports map using the Container Port Mapping feature. It is a simple to use yet flexible feature that supports common TCP protocols like HTTP and HTTPS as well as custom TCP and UDP traffic.

<h3 id="data_sources">Adding Data Sources</h3>


<h3 id="choosing_cloud">Choosing Cloud</h3>



<h3 id="choosing_server">Choosing Server Size</h3>
When deploying your stack, you are asked to specify a server size for the deployment. If you're testing Cloud 66, you may be inclined to do so on as small a server as possible. <b>We recommend that you do not do this, as this will come at a detriment to your experience with the service.</b>

When your stack is built for the first time, a number of packages are built from source, along with other memory intensive operations. Though we create a [swap file](http://www.computerhope.com/jargon/s/swapfile.htm) on small servers by default, to avoid it running out of memory, running on low resources will cause your build to take longer than normal.

## Under-powered server sizes (not recommended)

### Amazon Web Services
- t1.micro
- t2.micro

### Cloud-A
- 512 MB - General Purpose

### DigitalOcean
- 512MB - 1 CPU

### Google Compute Engine
- f1-micro

### Microsoft Azure
- A0

### Rackspace
- 512MB Standard Instance
- 512MB Standard Instance (HVM)

### Vexxhost
- nb.512M

**We suggest using a server with at least 1GB of memory and 4 cores**

In particular, Elasticsearch on a standalone under-powered server will not start up. This is because we configure Elasticsearch to lock its memory and prevent swapping on standalone servers as per the [official recommendation](https://www.elastic.co/guide/en/elasticsearch/guide/current/heap-sizing.html), and there is simply not enough memory for it to run it successfully.

Depending on whether or not you have deployed your application elsewhere, it may be hard to gauge the amount of resources that you need. On a PaaS like Heroku for example, you can choose between 1X (512 MB), 2X (1 GB) and PX (6 GB) server sizes. This makes it easy to calculate your server requirements, and we recommend that you use similar server resources when deploying your stack with Cloud 66. We also recommend that you have a seperate server for your database in production environments.

If you have yet to deploy your application in a production environment, you can deploy to a reasonably sized server and use [load testing](/articles/optimizing-for-server-load) to determine your exact needs.



Setup deployment

<h3 id="environment">Choosing Environment</h3>

<h3 id="Deploy">Build/Deploy</h3>

Choose Server size

You can add the following data sources to your stack: PostgreSQL, MySQL, MongoDB,Redis, Elastic Search, Rabbit MQ, Glusterfs,Influxdb

Note: You can install any of these on to a server, but remember that you can only have one of each.

So for instance you can add all of these a server but you cannot have two MySQL

Glusterfs needs its own server. i.e cannot share the server with any other data source 

<h2 id="data_sources">Adding Data Sources</h2>

1. PostgreSQL
2. MySQL
3. MongoDB
4. Redis
5. ElasticSearch
6. Rabbit MQ
7. Glusterf
8. Influxdb

<h3 id="service_networking">Service Networking</h3>

Container Port:

A normal application listens to port 3000 or 9292 by default.

Public Internet Port: 

Often times the purpose of a service inside your application is to respond to web queries from the internet. Actions like rendering and serving HTML pages or accepting HTTP POST actions are amongst the most common requirements from web services.

In a Cloud 66 for Docker stack, your services run inside containers. For this service to be available to anyone outside the container, we need to bridge it from inside to outside of the container.

This is not limited to HTTP or web traffic. The same concepts apply if your container serves non-HTTP traffic (like web sockets, DB containers or custom TCP / UDP traffic).
Note

In this article, outside world is used for any client of your service that's not inside the container. This includes any other services on your other stacks.
Ports inside and outside containers

Your code that runs inside of a container listens to a specific port. For example a standard setup for a web server listens to port 80 for HTTP and 443 for HTTPS traffic. A normal Rails application listens to port 3000 or 9292 by default.

Here is an example of default ports used by different programming frameworks or application servers:
Application 	Default Port
Rack (webrick)	3000
Rack (unicorn, thin, puma)	9292
Node (Express)	3000
Java (Play)	9000
RethinkDB	8080
InfluxDB	8083, 8086, 8090, 8099

From the outside world (ie Internet) all of these applications (except for the DBs) listen to the normal HTTP (80) and HTTPS (443) ports so the site visitors donâ€™t need to enter port number in their browsers.

On a Cloud 66 for Docker stack, you can make the inside and outside ports map using the Container Port Mapping feature. It is a simple to use yet flexible feature that supports common TCP protocols like HTTP and HTTPS as well as custom TCP and UDP traffic.

 
<h3 id="choosing_cloud">Choosing Server Size</h3>





  Add Another Server




   Deploy cia_onboarding to 

   Server Deployment Region

